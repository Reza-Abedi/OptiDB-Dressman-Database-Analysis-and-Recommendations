# OptiDB-Dressman-Database-Analysis-and-Recommendations
The selection of the name 'Dressmann' is purely hypothetical in the context of this assignment.

 
## Summary of the Database Structure and Business Rules
This report delves into the considerations for improving the Dressman database, focusing on documentation, data types, and specific constraints within the database schema. It provides an in-depth examination of constraints related to user, address, payment method, product category, product, shopping cart, order, order item, review, favorite, and promotion. Additionally, it outlines the implementation of outlet functionality in the Product table. The second part of the report offers an overview of queries and operations performed on the Dressman database, covering data retrieval, analysis, and optimization techniques.
This comprehensive database system is designed to manage various aspects of an e-commerce platform, from user information to product categorization, orders, and promotional activities. Key business rules and constraints have been implemented to ensure data integrity and meaningful relationships among entities. Below is a summary of the database's vision and its essential components:
 
## Strengths
#### Normalization: 
The tables seem to be normalized, reducing redundancy and improving data integrity.
#### Clear Relationships:
Relationships between entities are well-defined using foreign keys, ensuring data consistency.
#### Automated ID Generation:
The use of sequences and default constraints for user and product IDs automates the generation of unique identifiers, streamlining data entry.
#### Flexibility
The design allows for flexibility, such as multiple addresses and payment methods per user, supporting diverse user scenarios.
#### Hierarchical Product Categorization: 
The inclusion of a hierarchical structure for product categories enables a systematic and organized approach to product classification.
Considerations for Improvement
#### Documentation: 
While my SQL statements provide clarity on table creation and constraints, adding comments or documentation would enhance readability and understanding, especially for others who might work with or review the database.
#### Data Types: 
Ensure that data types are chosen appropriately for each field. For example, consider using more specific data types like INT for user IDs instead of NVARCHAR(10).
#### Outlet Functionality:
The introduction of an "IsInOutlet" column is a useful feature. However, consider providing additional information or documentation on how the outlet functionality is intended to work, including any business rules related to it.

Constraints in the Database Schema
This section outlines key business rules and constraints embedded in the database schema to ensure data integrity and meaningful relationships among entities. From enforcing unique user identifiers to managing product categorization and customer interactions, these rules guide the behavior and structure of the database. The constraints serve as a foundation for maintaining accuracy and coherence in the representation of users, addresses, payment methods, products, shopping carts, orders, reviews, favorites, and promotions within the database system.

1.	User Constraints
Unique Email: Users must have a unique email address, ensuring that each user account is distinct and identifiable by their email.
Automated User IDs: User IDs are automatically generated in the format 'U' followed by a unique identifier, streamlining the creation of user identifiers.
The addition of the default constraint named "DF_UserID" to the "Users" table for the "UserID" column serves as a critical enhancement to the database design. This constraint is designed to automate the assignment of unique identifiers to users during the insertion process, providing a seamless and efficient means of managing user data.
The default constraint utilizes a combination of the letter 'U' and the values generated by the "UserIDSequence" sequence. By concatenating these elements and casting the result as NVARCHAR(10), a distinctive and meaningful "UserID" is automatically assigned to users when they are added to the system. This default constraint ensures that when a new record is inserted into the "Users" table without explicitly specifying a value for the "UserID" column, it will automatically generate a unique "UserID" based on the combination of 'U' and the next value from the "UserIDSequence" sequence. 

2.	Address Constraints
Multiple Addresses: Each user can have multiple addresses, facilitating flexibility in representing diverse user locations.
Default Address: Users can designate at most one address as the default, simplifying address management and ensuring clarity in user profiles. 
IsDefault: A binary indicator (BIT) that signifies whether an address is the default address for a particular user. This field is crucial for applications that need to identify a user's primary or default address efficiently.
	One User can have multiple addresses, but each address belongs to only one user.

3.	Payment Method Constraints:
When a user adds a new payment method to their profile, they are presented with an option to mark it as the default method. This designation is achieved by setting the "IsDefaultPaymentMethod" attribute to 1 (true) for the newly added payment method. The introduction of this feature aims to simplify the payment process for users by ensuring that the marked default method is automatically selected for transactions.
Multiple Payment Methods: Users can have multiple payment methods, accommodating diverse financial preferences.
Default Payment Method: Each user can set at most one payment method as the default, simplifying payment processes.
	One User can have multiple payment methods, but each payment method belongs to only one user.

4.	Product Category Constraints:
The database schema incorporates a hierarchical structure for product categorization, allowing categories to possess subcategories through the utilization of the ParentCategoryID. This design feature facilitates a layered and organized system, enabling the establishment of parent-child relationships within the product categorization framework. As a result, products can be systematically classified into broader categories and further subcategorized, providing a flexible and scalable structure for efficient data organization and retrieval
	Categories can have subcategories through the ParentCategoryID.

5.	Product Constraints:
Automated Product IDs: Product identification is streamlined through the automated generation of unique Product IDs. Each Product ID follows the format 'P' followed by a unique identifier. This approach ensures a systematic and standardized way of uniquely identifying each product in our database. The automated generation of Product IDs enhances efficiency in product management and facilitates accurate referencing throughout the system.
Categorical Association: A pivotal aspect of our database design is the association of each product with a specific category. This categorization framework provides a hierarchical structure for organizing and classifying our diverse range of products. By linking each product to a predefined category, we enhance the navigability and clarity of our product catalog. Customers and system users can easily locate and comprehend the context of each product within its designated category.
	Product IDs are automatically generated as 'P' followed by a unique identifier.
	Each product belongs to a specific category.

6.	Shopping Cart Constraints:
In our database schema, I have implemented a feature that allows users to have multiple products in their shopping cart. This functionality is designed to enhance the user experience by providing flexibility and convenience during the shopping process.
	Users can have multiple products in their shopping cart.


7.	Order Constraints:
Order ID Generation: Order IDs within the system are automatically generated using a unique identifier preceded by the letter 'O.' This automated process ensures that each order is assigned a distinctive and easily recognizable identifier. The structured format not only aids in the efficient tracking of orders but also simplifies data management by providing a consistent nomenclature.
User Association: Each order is explicitly associated with a specific user. This relational link establishes a direct connection between a customer and their respective orders. This association is crucial for tracking and organizing orders based on user preferences and transaction history. By tying orders to individual users, the system enables personalized order management, facilitating a more tailored and user-centric experience.
	Order IDs are automatically generated as 'O' followed by a unique identifier.
	Orders are associated with a specific user.

8.	Order Item Constraints:
In the database schema, specific constraints govern the relationships and structures associated with order items. The following outlines the key constraint related to order items:
Within the database, each order has the capability to encompass multiple items. This constraint is designed to accommodate scenarios where customers can include numerous products within a single order. By allowing for the association of multiple items with a given order, the database supports the practicality of diverse purchasing behaviors, enabling customers to consolidate various products into a unified transaction.
This constraint contributes to the flexibility of the database structure, accommodating the dynamic nature of customer preferences and purchase patterns.
	Each order can have multiple items.

9.	Review Constraints:
Association with Product and User: Reviews are intricately tied to both a specific product and an individual user, ensuring that each review is contextually linked to the product being assessed and the user providing the feedback.
Significance: This constraint enables a comprehensive understanding of product reviews, allowing for targeted analysis of user opinions and preferences for specific products. It facilitates personalized insights into product performance and user experiences, contributing to informed decision-making for both customers and administrators.
Implementation: The database enforces a relationship between the Reviews table and the Products and Users tables through foreign key constraints. Each review record is connected to the corresponding product and user, forming a crucial link in capturing and interpreting user feedback accurately.
	Reviews are associated with a specific product and user.

10.	Favorite Constraints:
This section outlines the constraints governing the management of user favorites in the database schema, emphasizing the flexibility for users to mark multiple products as favorites. These constraints ensure a personalized and dynamic user experience, allowing individuals to curate and manage a collection of preferred items within the system.
Multiple Products as Favorites:  Users are granted the capability to mark multiple products as favorites, providing a versatile and personalized approach to curating their preferred items.
Significance: This constraint enhances user engagement and satisfaction by allowing individuals to express diverse preferences and interests. Users can build a curated collection of favorite products, facilitating easy access to items of interest and promoting a more tailored shopping experience.
Implementation: The database enforces this constraint by maintaining a relationship between the Users table and the Favorites table. Users can associate with multiple products as favorites, and the uniqueness constraint ensures that each user-product association is distinct, avoiding redundancy in the favorite list.
	Users can mark multiple products as favorites.

11.	Promotion Constraints:
This section outlines how the database structure handles and restricts special offers, where a product can be on sale (a certain percentage off the original price) for a specified period.
Significance: This constraint allows for a targeted and strategic approach to marketing, ensuring that promotions are aligned with specific products based on business objectives and customer preferences. It facilitates efficient promotion management, enabling administrators to tailor discount strategies and promotional campaigns for individual products or product categories.
Implementation: The database enforces a relationship between the Promotions table and the Products table through foreign key constraints. Each promotion record is associated with a particular product, creating a direct connection that streamlines the identification and application of promotions during marketing initiatives.
	Promotions are associated with specific products.

OUTLET
In the Product table, a column named "IsInOutlet" has been added, and it is of the BOOLEAN (BIT) type. When "IsInOutlet" is marked as true (1), it signifies that the product is considered an Outlet product with a discounted price.
This allows the management and display of Outlet prices exclusively online through the utilization of the new "IsInOutlet" column in your Product table.
Implementing the Outlet Functionality: Products intended for the Outlet are identified by changing the value of the "IsInOutlet" column to 1 when it is desirable to include them in Outlet offerings.
When users visit our website and view products, the "IsInOutlet" value is used to indicate that these products are available in the Outlet, and the prices are applicable only online.
 
 
Assignment Report: Database Queries and Operations for Dressman Database
Overview:
The queries and operations performed on the Dressman database span a range of tasks, from basic data retrieval to more complex analysis and optimization techniques. This report provides a comprehensive summary of the SQL queries, stored procedures, views, and an index implemented for various purposes within the Dressman database.

1. Retrieve User Contact Information:
The first query aims to fetch detailed contact information for a specific user identified by their first and last name. Utilizing an INNER JOIN between Users and UserAddress, this query offers a glimpse into the detailed user profile.
 
2. Identify the User with the Highest Spending:
To achieve this objective, the query employs an INNER JOIN operation between the Users and Orders tables. This ensures that only the records where user data aligns with order information are considered, narrowing the focus to users who have engaged in transactions. The aggregation function SUM is then applied to calculate the total amount spent by each user, grouping the results by the unique user identifiers. 
3. Retrieve Users and Their Orders from a Specific Country:
The query begins by declaring a variable, @Country, to allow flexibility in choosing the desired country. In this example, the variable is initialized with 'Italy'.
The subsequent SELECT statement employs JOIN operations to gather relevant data. It involves the Users (U), UserAddress (A), and Orders (O) tables.
User Data Retrieval: The Users table (alias U) is joined with the UserAddress table (alias A) using the common field UserID. This ensures that user information and their corresponding addresses are linked.
Order Data Retrieval: A LEFT JOIN is established with the Orders table (alias O) based on the user ID. This type of join ensures that all users, regardless of order history, are included in the result.
Filtering by Country: The WHERE clause specifies that the query should only consider users from the country specified by the @Country variable. 
 

4. Find the Most Expensive Product:
For merchandising insights, this query identifies the most expensive product in the store by leveraging a straightforward SELECT statement with TOP 1 and ORDER BY clauses.
 
5. Total Number of Products in Stock:
The query calculates the total number of products available, contributing to a holistic view of stock levels.
 

6. Total Value of All Products:
In the realm of financial analysis, the sixth query calculates the total monetary value of all products, demonstrating the cumulative worth of Dressman's inventory.
Product-Level Calculation: The query starts by calculating the total value for each individual product by multiplying the unit price (p.price) with the available quantity (pi.AvailableQuantity).
The results are grouped by ProductID, ProductName, price, and StockQuantity, providing a detailed breakdown of the monetary value for each product.
Grand Total Calculation: A UNION statement is used to append a row representing the grand total to the result set. The grand total row summarizes the overall value of Dressman's entire inventory by summing up the total values of all individual products.
 

7. Total Quantity Sold for Each Product in Each City:
This complex query integrates GROUP BY to provide insights into the total quantity sold for each product in every city, accompanied by customer information.
GROUP BY Clause: The GROUP BY clause is applied to the columns FirstName, LastName, City, ProductID, and ProductName.
This grouping is essential to aggregate data based on these attributes.
Aggregate Function (SUM): The SUM function is employed to calculate the total quantity sold for each product in every city.

 

8. User Information with Order Statistics:
To better understand user behavior, the eighth query combines user information with essential order statistics such as the number of orders, minimum, maximum, total, and average order amounts.
 
9. Sort Orders by User and Date Ascending:
Order management is facilitated through the ninth query, which arranges orders chronologically by user and date in ascending order.
 
10. Filter Orders Based on Variable:
The use of variables in SQL is showcased in the tenth query, allowing for dynamic filtering of orders based on a minimum order amount.
 
 
11. Stored Procedures:
Two stored procedures, GetUserInformation and GetOrdersByUser, have been crafted to encapsulate common queries. These stored procedures enhance reusability and maintainability of code.
 
 
12. Conditional Retrieval Based on Favorites:
The query employs an IF statement to check for the existence of user favorites by inspecting the Favorites table for entries corresponding to the specified UserID. If favorites are found, it retrieves the UserID, ProductID, and ProductName from the Users, Favorites, and Products tables. In contrast, if no favorites exist, a message is printed to indicate the absence of favorites for the specified user.
 
13. SQL Views: CustomerOrders and ProductTotalSales:
Two SQL views have been created to encapsulate complex queries. CustomerOrders consolidates user and order details, while ProductTotalSales provides an overview of total sales for each product.
 
 
14. Query with Subquery: User Activity and Timestamp:
A subquery is employed in the fourteenth query to fetch a list of users along with their latest activity type and timestamp.
The query 1 utilizes subqueries within the SELECT statement to extract information about the latest activity type and timestamp for each user. Two subqueries are employed—one to retrieve the latest activity type (ActivityType) and another to obtain the corresponding timestamp (ActivityTimestamp). The subqueries are structured to select only the top (most recent) record for each user from the UserActivity table, ordered by the activity timestamp in descending order.
The query2 achieves this by selecting all columns from the "Products" table where the "ProductID" is present in the result set obtained from the nested SELECT statement. The nested SELECT statement retrieves "ProductID" entries from the "Promotions" table where the "DiscountPercentage" exceeds 15.00

 
15. Index Creation:
To enhance performance, two indexes have been created—one on UserAddress(UserID) and another on Orders(UserID). These indexes are pivotal in expediting data retrieval operations.

 

